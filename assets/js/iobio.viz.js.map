{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/viz.js","node_modules/extend/index.js","src/layout/graph.js","src/layout/layout.js","src/layout/outlier.js","src/layout/pileup.js","src/layout/pointSmooth.js","src/svg/svg.js","src/svg/variant.js","src/utils.js","src/viz/alignment.js","src/viz/bar.js","src/viz/barViewer.js","src/viz/base.js","src/viz/gene.js","src/viz/line.js","src/viz/multiLine.js","src/viz/pie.js","src/viz/referenceGraph.js","src/viz/viz.js"],"names":[],"mappings":"AAAA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClIA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"iobio.viz.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*  Chase Miller (2015-2016) */\n\n// Grab an existing iobio namespace object, or create a blank object\n// if it doesn't exist\nvar iobio = global.iobio || {};\nglobal.iobio = iobio;\n\n// export if being used as a node module - needed for test framework\nif ( typeof module === 'object' ) { module.exports = iobio;}\n\n// Add visualizations\niobio.viz = require('./viz/viz.js')\n\n// Add layouts\niobio.viz.layout = require('./layout/layout.js')\n\n// Add shapes\niobio.viz.svg = require('./svg/svg.js')\n\n// Add utils\niobio.viz.utils = require('./utils.js')\n","var hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\nvar undefined;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\t'use strict';\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar has_own_constructor = hasOwn.call(obj, 'constructor');\n\tvar has_is_property_of_method = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !has_own_constructor && !has_is_property_of_method) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) {}\n\n\treturn key === undefined || hasOwn.call(obj, key);\n};\n\nmodule.exports = function extend() {\n\t'use strict';\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[0],\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = target[name];\n\t\t\t\tcopy = options[name];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target === copy) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[name] = extend(deep, clone, copy);\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if (copy !== undefined) {\n\t\t\t\t\ttarget[name] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\n","var utils = require('../utils.js');\n\nvar graph = function() {\n    // Defaults\n    var sources = function(d) { return d.sources },\n        targets = function(d) { return d.targets },\n        position = function(d) { return d.position };\n    \n    function layout(root) {\n    \tvar nodes = [];\n    \tvar visited = {};\n    \tvar uid = utils.getUID();\n    \tvar stack = [ root ];\n    \twhile ((node = stack.pop()) != null) {\n    \t\tif (node._visited == uid) continue;\n    \t\tnodes.push(node);\n    \t\t// mark as visited\n    \t\tnode._visited = uid;\n    \t\t// see if multiple variants at this position\n    \t\tvar v = visited[position(node)] || (visited[position(node)]=[]);\n    \t\tv.push(node);\n    \t\tif (v.length ==1 )\n    \t\t\tnode.y = 0;\n    \t\telse \n    \t\t\tfor (var i=0; i<v.length; i++) {v[i].y = (i/(v.length-1) || 0) * 2 - 1;}    \t\t\n\n    \t\t// push unvisited neighbors on stack\n    \t\tvar neighbors = [].concat(sources(node), targets(node));    \t\t    \t\t\n    \t\tstack = stack.concat( neighbors.filter(function(a) {return a._visited != uid;}) )\n    \t}\n    \treturn nodes;\n    }\n\n    /*\n     * Identifies the links between all nodes\n     */\n    layout.links = function(nodes) {\n    \tvar links = [];\n    \tnodes.forEach(function(node) {\n    \t\t(node.targets || []).map(function(target) {\n\t        \tlinks.push( {\n\t          \t\t'source': node,\n\t          \t\t'target': target\n\t        \t});\n\t        });\n    \t})\n\t    return links;\n    }\n\n    /*\n     * Specifies the value function *sources*, which returns an array of node objects\n     * for each datum. The default value function is `return sources`. The value function\n     * is passed two arguments: the current datum and the current index.\n     */    \n    layout.sources = function(_) {\n        if (!arguments.length) return sources;\n            sources = _;\n            return chart;\n    }\n\n    /*\n     * Specifies the value function *targets*, which returns an array of node objects\n     * for each datum. The default value function is `return targets`. The value function\n     * is passed two arguments: the current datum and the current index.\n     */\n    layout.targets = function(_) {\n        if (!arguments.length) return targets;\n            targets = _;\n            return chart;\n    }\n\n    /*\n     * Specifies the value function *position*, which returns a nonnegative numeric value\n     * for each datum. The default value function is `return position`. The value function\n     * is passed two arguments: the current datum and the current index.\n     */\n    layout.position = function(_) {\n        if (!arguments.length) return position;\n            position = _;\n            return chart;\n    }\n    // TODO: do these functions still make sense?\n    // layout.size = function(x) {\n    //   if (!arguments.length) return nodeSize ? null : size;\n    //   nodeSize = (size = x) == null ? sizeNode : null;\n    //   return tree;\n    // };\n    // layout.nodeSize = function(x) {\n    //   if (!arguments.length) return nodeSize ? size : null;\n    //   nodeSize = (size = x) == null ? null : sizeNode;\n    //   return tree;\n    // };\n    return layout;\n  };\n \n module.exports = graph;","\nvar layout = {};\n// add layouts\nlayout.pileup = require('./pileup.js');\nlayout.graph = require('./graph.js');\nlayout.pointSmooth = require('./pointSmooth.js');\nlayout.outlier = require('./outlier.js');\n\nmodule.exports = layout;","\n\nvar outlier = function() {\n  // Defaults\n  var value = function(d) { return d[0]; },\n      count = function(d) { return d[1]; };\n\n  function layout(data) {\n    var q1 = quantile(data, 0.25); \n    var q3 = quantile(data, 0.75);\n    var iqr = (q3-q1) * 1.5; //\n    \n    return data.filter(function(d) { return (value(d)>=(Math.max(q1-iqr,0)) && value(d)<=(q3+iqr)) });\n  }\n\n  /*\n   * Determines quantile of array with given p\n   */\n  function quantile(arr, p) {\n    var length = arr.reduce(function(previousValue, currentValue, index, array){\n       return previousValue + count(currentValue);\n    }, 0) - 1;\n    var H = length * p + 1, \n    h = Math.floor(H);\n\n    var hValue, hMinus1Value, currValue = 0;\n    for (var i=0; i < arr.length; i++) {\n       currValue += count(arr[i]);\n       if (hMinus1Value == undefined && currValue >= (h-1))\n          hMinus1Value = value(arr[i]);\n       if (hValue == undefined && currValue >= h) {\n          hValue = value(arr[i]);\n          break;\n       }\n    } \n    var v = +hMinus1Value, e = H - h;\n    return e ? v + e * (hValue - v) : v;\n  } \n\n  /*\n   * Specifies the value function *value*, which returns a nonnegative numeric value\n   * for each datum. The default value function is `return d[0]`. The value function\n   * is passed two arguments: the current datum and the current index.\n   */\n  layout.value = function(_) {\n    if (!arguments.length) return value;\n    value = _;\n    return layout;\n  };\n\n  /*\n   * Specifies the value function *count*, which returns a nonnegative numeric value\n   * for each datum. The default value function is `return d[1]`. The value function\n   * is passed two arguments: the current datum and the current index.\n   */\n  layout.count = function(_) {\n    if (!arguments.length) return count;\n    count = _;\n    return layout;\n  };  \n\n  return layout;\n};\n\nmodule.exports = outlier;\n","\n\nvar pileup = function() {\n  // Defaults\n  var startValue = function(d) { return d.start; },\n      endValue = function(d) { return d.end; },\n      sort = 'default',\n      size = 400,\n      buffer = 0;\n\n  function layout(data) {\n\n    // Compute the numeric values for each data element.\n    var values = data.map(function(d, i) { return [+startValue.call(layout, d, i),+endValue.call(layout, d, i)]; });\n    var xScale = d3.scale.linear()\n            .domain( [values[0][0], values[values.length-1][1]] )\n            .range([0, size]);\n\n    // Optionally sort the data.\n    var index = d3.range(data.length);\n    if (sort != null) index.sort(sort === 'default'\n        ? function(i, j) { return values[j][0] - values[i][0]; }\n        : function(i, j) { return sort(data[i], data[j]); });\n\n    // Compute the piles!\n    // They are stored in the original data's order.\n    // TODO: handle widhts that are less than a pixel\n    var step;\n    var piles = [];\n    var furthestRight = [];\n\n    // initialize piles\n    var currPile = [];\n    var prevPile = [];\n    var prevPrevPile = [];\n\n    // initialize indices\n    var prevPileIndex = 1;\n\n    index.forEach(function(i) {\n      var start = values[i][0];\n      var end = values[i][1];\n      step = undefined;\n\n      for ( var k=0; k < furthestRight.length; k++) {\n        if ( (xScale(furthestRight[k])+buffer) < xScale(start) ) {\n          step = k;\n          furthestRight[k] = end;\n          break;\n        }\n      }\n\n      if (step == undefined) { step = furthestRight.length; furthestRight.push(end) }\n\n      piles[i] = {\n        data: data[i],\n        x: start,\n        w: end-start,\n        y: step\n      };\n    });\n    return piles;\n  }\n\n  /*\n   * Specifies the value function *start*, which returns a nonnegative numeric value\n   * for each datum. The default value function is `return start`. The value function\n   * is passed two arguments: the current datum and the current index.\n   */\n  layout.start = function(_) {\n    if (!arguments.length) return startValue;\n    startValue = _;\n    return layout;\n  };\n\n  /*\n   * Specifies the value function *end*, which returns a nonnegative numeric value\n   * for each datum. The default value function is `return end`. The value function\n   * is passed two arguments: the current datum and the current index.\n   */\n  layout.end = function(_) {\n    if (!arguments.length) return endValue;\n    endValue = _;\n    return layout;\n  };\n\n  /*\n   * Specifies the x scale for the layout. This is necessary to accurately predict\n   * which features will overlap in pixel space.\n   */\n  layout.size = function(_) {\n    if (!arguments.length) return size;\n    size = _;\n    return layout;\n  };\n\n  /*\n   * Specifies the buffer needed between features to not be considered an overlap\n   */\n  layout.buffer = function(_) {\n    if (!arguments.length) return buffer;\n    buffer = _;\n    return layout;\n  };\n\n  /*\n   * Specifies the sort function to be used or null if no sort\n   */\n  layout.sort = function(_) {\n    if (!arguments.length) return sort;\n    sort = _;\n    return layout;\n  };\n\n  return layout;\n};\n\nmodule.exports = pileup;","\n\nvar pointSmooth = function() {\n  // Defaults\n  var pos = function(d) { return d.pos; },\n      depth = function(d) { return d.depth; },\n      size = 400;\n      epsilonRate = 0.3;\n\n  function layout(data) {\n\n    // Compute the numeric values for each data element and keep original data.    \n    var points = data.map(function(d, i) { \n      return {\n        data: d,\n        pos: +pos.call(layout, d, i),\n        depth: +depth.call(layout, d, i)\n      };\n    });\n    \n    var epislon = parseInt( epsilonRate * (points[points.length-1].pos - points[0].pos) / size );\n\n    // Compute the points!\n    // They are stored in the original data's order.\n    points = properRDP(points, epislon);    \n    \n    return points;\n  }\n\n  /*\n   * Specifies the value function *pos*, which returns a nonnegative numeric value\n   * for each datum. The default value function is `return pos`. The value function\n   * is passed two arguments: the current datum and the current index.\n   */\n  layout.pos = function(_) {\n    if (!arguments.length) return pos;\n    pos = _;\n    return layout;\n  };\n\n  /*\n   * Specifies the value function *depth*, which returns a nonnegative numeric value\n   * for each datum. The default value function is `return depth`. The value function\n   * is passed two arguments: the current datum and the current index.\n   */\n  layout.depth = function(_) {\n    if (!arguments.length) return depth;\n    depth = _;\n    return layout;\n  };\n\n  /*\n   * Specifies the x scale for the layout. This is necessary to accurately predict\n   * how smoothing will be necessary i.e. smaller size has less resolution and will \n   * require more smoothing.\n   */\n  layout.size = function(_) {\n    if (!arguments.length) return size;\n    size = _;\n    return layout;\n  };\n\n  /*\n   * Specifies the epislon rate to determine the aggressiveness of the smoothing   \n   */\n  layout.epsilonRate = function(_) {\n    if (!arguments.length) return epsilonRate;\n    epsilonRate = _;\n    return layout;\n  };\n\n  return layout;\n};\n\nmodule.exports = pointSmooth;\n\n\n/*\n * properRDP\n * \n * @licence Feel free to use it as you please, a mention of my name is always nice.\n * \n * Marius Karthaus\n * http://www.LowVoice.nl\n * \n */ \n\nfunction properRDP(points,epsilon){\n    var firstPoint=points[0];\n    var lastPoint=points[points.length-1];\n    if (points.length<3){\n        return points;\n    }\n    var index=-1;\n    var dist=0;\n    for (var i=1;i<points.length-1;i++){\n        var cDist=findPerpendicularDistance(points[i],firstPoint,lastPoint);\n        if (cDist>dist){\n            dist=cDist;\n            index=i;\n        }\n    }\n    if (dist>epsilon){\n        // iterate\n        var l1=points.slice(0, index+1);\n        var l2=points.slice(index);\n        var r1=properRDP(l1,epsilon);\n        var r2=properRDP(l2,epsilon);\n        // concat r2 to r1 minus the end/startpoint that will be the same\n        var rs=r1.slice(0,r1.length-1).concat(r2);\n        return rs;\n    }else{\n        return [firstPoint,lastPoint];\n    }\n}\n\nfunction findPerpendicularDistance(p, p1,p2) {\n    // if start and end point are on the same x the distance is the difference in X.\n    var result;\n    var slope;\n    var intercept;\n    if (p1.pos==p2.pos){\n        result=Math.abs(p.pos-p1.pos);\n    }else{\n        slope = (p2.depth - p1.depth) / (p2.pos - p1.pos);\n        intercept = p1.depth - (slope * p1.pos);\n        result = Math.abs(slope * p.pos - p.depth + intercept) / Math.sqrt(Math.pow(slope, 2) + 1);\n    }\n   \n    return result;\n}","\nvar svg = {};\n// add shapes\nsvg.variant = require('./variant.js');\n\nmodule.exports = svg;","var variant = function() { \n    \n    // Value transformers\n    var xValue = function(d) { return d.x; },\n        yValue = function(d) { return d.y; },\n        wValue = function(d) { return d.w; },\n        hValue = function(d) { return d.h; };\n\n    var diagonal = d3.svg.diagonal()        \n\n    function shape(d, i) {    \n        diagonal\n            .source(function(d) { return {\"x\":hValue(d)*d.y, \"y\":d.x+Math.abs(d.w/2)}; })            \n            .target(function(d) { return {\"x\":0, \"y\":d.x+d.w/2+Math.abs(d.w/2)}; })\n            .projection(function(d) { return [d.y, d.x]; });\n        \n        var variantH = hValue(d);\n        var bulbW = Math.abs(variantH * 5/6);\n        // Create control points\n        var c1 = variantH * 1/6+yValue(d),\n            c2 = variantH*2/6+yValue(d),\n            c3 = variantH*0.625+yValue(d),\n            c4 = variantH*1.145+yValue(d);\n\n        if (wValue(d) <= Math.abs(bulbW/2))\n            return \"M\" +xValue(d)+\",\"+yValue(d)+\" C\" +xValue(d)+ \",\" +c1+\" \"+parseInt(xValue(d)+wValue(d)/2-bulbW/2)+ \",\" +c2+\" \"+parseInt(xValue(d)+wValue(d)/2-bulbW/2)+ \",\" +c3+\" C\" +parseInt(xValue(d)+wValue(d)/2-bulbW/2)+ \",\" +c4+\" \"+parseInt(xValue(d)+wValue(d)/2+bulbW/2)+ \",\" +c4+\" \"+parseInt(xValue(d)+wValue(d)/2+bulbW/2)+ \",\" +c3+\" C\" +parseInt(xValue(d)+wValue(d)/2+bulbW/2)+ \",\" +c2+\" \"+parseInt(xValue(d)+wValue(d))+\",\" +c1+\" \"+parseInt(xValue(d)+wValue(d))+\",\"+yValue(d);            \n        else\n            return diagonal(d)+diagonal({x:xValue(d), y:yValue(d), w:-wValue(d)});\n    }\n\n    /*\n     * Specifies the value function *x*, which returns an integer for each datum\n     * The value function is passed two arguments: the current datum and the current index.\n     */  \n    shape.xValue = function(_) {\n        if (!arguments.length) return xValue;\n        xValue = _;\n        return shape;\n    }\n\n    /*\n     * Specifies the value function *y*, which returns an integer for each datum\n     * The value function is passed two arguments: the current datum and the current index.\n     */  \n    shape.yValue = function(_) {\n        if (!arguments.length) return yValue;\n        yValue = _;\n        return shape;\n    };\n\n    /*\n     * Specifies the value function *width*, which returns an integer for each datum\n     * The value function is passed two arguments: the current datum and the current index.\n     */  \n    shape.wValue = function(_) {\n        if (!arguments.length) return wValue;\n        wValue = _;\n        return shape;\n    }; \n\n    /*\n     * Specifies the value function *height*, which returns an integer for each datum\n     * The value function is passed two arguments: the current datum and the current index.\n     */  \n    shape.hValue = function(_) {\n        if (!arguments.length) return hValue;\n        hValue = _;\n        return shape;\n    }; \n\n    return shape;\n};\n\nmodule.exports = variant;","\nmodule.exports.format_unit_names = function(d) {\n\tif ((d / 1000000) >= 1)\n\t\td = d / 1000000 + \"M\";\n\telse if ((d / 1000) >= 1)\n\t\td = d / 1000 + \"K\";\n\treturn d;            \n}\n\nmodule.exports.format_percent = function(d, precision_places) {\n\tvar precision_places = precision_places || 1;\n\t\t\n\tvar corrector = 1;\n\tfor (var i=0; i < precision_places; i++) { corrector *= 10}\n\n\tvar percent = parseInt( d * (corrector*100) ) / corrector;\n\n\treturn percent;            \n}\n\nmodule.exports.getUID = function(separator) {    \t\n    var delim = separator || \"-\";\n\n    function S4() {\n        return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);\n    }\n\n    return (S4() + S4() + delim + S4() + delim + S4() + delim + S4() + delim + S4() + S4() + S4());\t\n}\n\nmodule.exports.value_accessor = function(value, d) {\n\treturn typeof value === 'function' ? value(d) : value;\n}\n\nmodule.exports.tooltipHelper = function(selection, tooltipElem, titleAccessor) {\n\tvar utils = require('./utils.js')\n\tselection\n\t\t.on(\"mouseover\", function(d,i) {    \n\t\t\tvar tooltipStr = utils.value_accessor(titleAccessor, d); // handle both function and constant string\n\t\t\tvar opacity = tooltipStr ? .9 : 0; // don't show if tooltipStr is null\t\t\t\n\t\t\ttooltipElem.transition()        \n\t\t\t\t.duration(200)      \n\t\t\t\t.style(\"opacity\", opacity);\t\t\t\n\t\t\ttooltipElem.html(tooltipStr)\n\t\t\t\t.style(\"left\", (d3.event.clientX) + \"px\") \n\t\t\t\t.style(\"text-align\", 'left')\n\t\t\t\t.style(\"top\", (d3.event.clientY - 24) + \"px\");\n\t\t})\n\t\t.on(\"mouseout\", function(d) {       \n\t\t\ttooltipElem.transition()        \n\t\t\t\t.duration(500)      \n\t\t\t\t.style(\"opacity\", 0);   \n\t\t})\n}\n\n// Copies a variable number of methods from source to target.\nmodule.exports.rebind = function(target, source) {\n  var i = 1, n = arguments.length, method;\n  while (++i < n) target[method = arguments[i]] = iobio_rebind(target, source, source[method]);\n  return target;\n};\n\n// Method is assumed to be a standard D3 getter-setter:\n// If passed with no arguments, gets the value.\n// If passed with arguments, sets the value and returns the target.\nfunction iobio_rebind(target, source, method) {\n  return function() {\n    var value = method.apply(source, arguments);\n    return value === source ? target : value;\n  };\n}","var alignment = function() {\n\t// Import base chart\n\tvar base = require('./base.js')(),\n\t\tutils = require('../utils.js'),\n\t\textend = require('extend');\n\n\t// Value transformers\n\tvar directionValue = null;\n\n\t// Defaults\n\tvar elemHeight = 4,\n\t\torientation = 'down',\n\t\tevents = [],\n\t\ttooltip;\n\n\t// Default Options\n\tvar defaults = { };\n\n\tfunction chart(selection, opts) {\n\t\t// Merge defaults and options\n\t\tvar options = {};\n\t\textend(options, defaults, opts);\n\n\t\t// Call base chart\n\t\tbase.call(this, selection, options);\n\n\t\t// Grab base functions for easy access\n\t\tvar x = base.x(),\n\t\t\ty = base.y(),\n\t\t\tid = base.id();\n\t\t\txValue = base.xValue(),\n\t\t\tyValue = base.yValue(),\n\t\t\twValue = base.wValue(),\n\t\t\tyAxis = base.yAxis(),\n\t\t\tcolor = base.color(),\n\t\t\ttransitionDuration = base.transitionDuration();\n\n\t\t// Change orientation of pileup\n\t\tif (orientation == 'down') {\n\t\t\t// swap y scale min and max\n\t\t\ty.range([y.range()[1],y.range()[0]]);\n\t\t\t// update y axis\n\t\t\tif(yAxis)\n\t\t\t\tselection.select(\".iobio-y.iobio-axis\").transition()\n\t\t\t\t\t.duration(0)\n\t\t\t\t\t.call(yAxis);\n\t\t}\n\n\t\t// Draw\n\n\n\t\tvar g = selection.select('g.iobio-container').classed('iobio-alignment', true); // grab container to draw into (created by base chart)\n\t\tvar aln = g.selectAll('.alignment')\n\t\t\t\t.data(selection.datum());\n\n\t\t// Enter\n\t\taln.enter().append('g')\n\t\t\t.attr('class', 'alignment')\n\t\t\t.attr('transform', function(d) {\n\t\t\t\tvar translate = 'translate('+parseInt(x(xValue(d) + wValue(d)/2))+','+ parseInt(y(yValue(d))-elemHeight/2) + ')'\n\t\t\t\tif (directionValue && directionValue(d) == 'reverse')\n\t\t\t\t\treturn translate + ' rotate(180)';\n\t\t\t\telse\n\t\t\t\t\treturn translate;\n\t\t\t})\n\t\t\t.append('polygon')\n\t\t\t\t.style('fill', color)\n\t\t\t\t.attr('id', function(d) { return id(d)})\n\t\t\t\t.attr('points', function(d) {\n\t\t\t\t\tvar rW = x(xValue(d)+wValue(d)) - x(xValue(d));\n\t\t\t\t\tvar rH = elemHeight;\n\t\t\t\t\tvar arrW = Math.min(5, rW);\n\n\t\t\t\t\tif (directionValue)\n\t\t\t\t\t\treturn ((-rW/2) + ',' + (-rH/2) + ' '\n\t\t\t\t\t\t\t  + (rW/2-arrW) + ',' + (-rH/2) + ' '\n\t\t\t\t\t\t\t  + (rW/2) + ',0 '\n\t\t\t\t\t\t\t  + (rW/2-arrW) + ',' + (rH/2) + ' '\n\t\t\t\t\t\t\t  + (-rW/2) + ',' + (rH/2));\n\t\t\t\t\telse\n\t\t\t\t\t\treturn ((-rW/2) + ',' + (-rH/2) + ' '\n\t\t\t\t\t\t\t  + (rW/2) + ',' + (-rH/2) + ' '\n\t\t\t\t\t\t\t  + (rW/2) + ',' + (rH/2) + ' '\n\t\t\t\t\t\t\t  + (-rW/2) + ',' + (rH/2));\n\t\t\t\t})\n\t\t\t// .append('rect')\n\t\t\t// \t.style('fill', color)\n\t\t\t// \t.attr('x', function(d) { return x(xValue(d)) })\n\t\t\t// \t.attr('y', function(d) { return y(yValue(d)) - elemHeight + 2 })\n\t\t\t// \t.attr('id', function(d) { return id(d)})\n\t\t\t// \t.attr('width', function(d) { return x(xValue(d)+wValue(d)) - x(xValue(d)); })\n\t\t\t// \t.attr('height', function(d) { return elemHeight });\n\n\t\taln.exit()\n\n\t\taln.attr('transform', function(d) {\n\t\t\t\tvar translate = 'translate('+parseInt(x(xValue(d) + wValue(d)/2))+','+ parseInt(y(yValue(d))-elemHeight/2) + ')'\n\t\t\t\tif (directionValue && directionValue(d) == 'reverse')\n\t\t\t\t\treturn translate + ' rotate(180)';\n\t\t\t\telse\n\t\t\t\t\treturn translate;\n\t\t\t})\n\n\t\taln.select('polygon').transition()\n\t\t\t.duration(transitionDuration)\n\t\t\t.style('fill', color)\n\t\t\t.attr('points', function(d) {\n\t\t\t\tvar rW = x(xValue(d)+wValue(d)) - x(xValue(d));\n\t\t\t\tvar rH = elemHeight;\n\t\t\t\tvar arrW = Math.min(5, rW);\n\n\t\t\t\tif (directionValue)\n\t\t\t\t\treturn ((-rW/2) + ',' + (-rH/2) + ' '\n\t\t\t\t\t\t  + (rW/2-arrW) + ',' + (-rH/2) + ' '\n\t\t\t\t\t\t  + (rW/2) + ',0 '\n\t\t\t\t\t\t  + (rW/2-arrW) + ',' + (rH/2) + ' '\n\t\t\t\t\t\t  + (-rW/2) + ',' + (rH/2));\n\t\t\t\telse\n\t\t\t\t\treturn ((-rW/2) + ',' + (-rH/2) + ' '\n\t\t\t\t\t\t  + (rW/2) + ',' + (-rH/2) + ' '\n\t\t\t\t\t\t  + (rW/2) + ',' + (rH/2) + ' '\n\t\t\t\t\t\t  + (-rW/2) + ',' + (rH/2));\n\t\t\t})\n\t\t// \t.attr('x', function(d) { return x(xValue(d)) })\n\t\t// \t.attr('y', function(d) { return y(yValue(d)) - elemHeight + 2 })\n\t\t// \t.attr('id', function(d) { return id(d)})\n\t\t// \t.attr('width', function(d) {\n\t\t// \t\treturn x(xValue(d)+wValue(d)) - x(xValue(d));\n\t\t// \t})\n\t\t// \t.attr('height', function(d) { return elemHeight });\n\n\t\t// Add title on hover\n\t    if (tooltip) {\n\t    \tvar tt = d3.select('.iobio-tooltip')\n\t    \tutils.tooltipHelper(g.selectAll('.alignment'), tt, tooltip);\n\t    }\n\n\t    // Attach events\n\t\tevents.forEach(function(ev) {\n\t\t\tvar cb = ev.listener ? function() {ev.listener.call(chart, svg)} : null;\n\t\t\tg.selectAll('.alignment').on(ev.event, cb);\n\t\t})\n\n\t}\n\t// Rebind methods in 2d.js to this chart\n\tbase.rebind(chart);\n\n\t/*\n\t * Value accessor for getting the direction of the alignment\n\t */\n\tchart.directionValue = function(_) {\n\t\tif (!arguments.length) return directionValue;\n\t\tdirectionValue = _;\n\t\treturn chart;\n\t};\n\n\t/*\n   \t * Specifies the orientation of the alignment. Can be 'up' or 'down'\n   \t */\n  \tchart.orientation = function(_) {\n    \tif (!arguments.length) return orientation;\n    \torientation = _;\n    \treturn chart;\n  \t};\n\n\t/*\n   \t * Set events on rects\n   \t */\n\tchart.on = function(event, listener) {\n\t\tif (!arguments.length) return events;\n\t\tevents.push( {'event':event, 'listener':listener})\n\t\treturn chart;\n\t}\n\n\t/*\n   \t * Set tooltip that appears when mouseover rects\n   \t */\n\tchart.tooltip = function(_) {\n\t\tif (!arguments.length) return tooltip;\n\t\t\ttooltip = _;\n\t\t\treturn chart;\n\t}\n\n\treturn chart;\n}\n\n// Export alignment\nmodule.exports = alignment;","var bar = function() {\n\t// Import base chart\n\tvar base = require('./base.js')(),\n\t\tutils = require('../utils.js'),\n\t\textend = require('extend');\n\n\t// Defaults\n\tvar events = [],\n\t\ttooltip;\n\n\t// Default Options\n\tvar defaults = { yMin: 0 };\n\n\tfunction chart(selection, opts) {\n\t\t// Merge defaults and options\n\t\tvar options = {};\n\t\textend(options, defaults, opts);\n\n\t\t// Call base chart\n\t\tbase.call(this, selection, options);\n\n\t\t// Grab base functions for easy access\n\t\tvar x = base.x(),\n\t\t\ty = base.y(),\n\t\t\tid = base.id();\n\t\t\txValue = base.xValue(),\n\t\t\tyValue = base.yValue(),\t\t\t\n\t\t\twValue = base.wValue(),\n\t\t\tcolor = base.color(),\n\t\t\ttransitionDuration = base.transitionDuration(),\n\t\t\tinnerHeight = base.height() - base.margin().top - base.margin().bottom;\t\t\n\n\t\t// Draw\n\t\t// enter\n\t\tvar g = selection.select('g.iobio-container').classed('iobio-bar', true);; // grab container to draw into (created by base chart)\t\t\n\t\tvar gData = g.selectAll('.rect')\n\t\t\t\t.data(selection.datum(), function(d) { return xValue(d); })\n\t\t// exit\n\t    gData.exit().remove();\n\t\t\t\n\t\t// enter\n\t\tgData.enter().append('g')\t\t\t\t\n\t\t\t.attr('class', 'rect')\t\t\t\n\t\t\t.style('fill', color )\n\t\t\t.append('rect')\t\t\t\t\t\n\t\t\t\t.attr('y', function(d) { return innerHeight })\n\t\t\t\t.attr('x', function(d) { return x(xValue(d)) })\n\t\t\t\t.attr('id', id )\t\t\t\t\n\t\t\t\t.attr('width', function(d) { return x(xValue(d)+wValue(d)) - x(xValue(d));})\t\t\t\t\n\t\t\t\t.attr('height', function(d) { return 0; });\n\n\t\t// update\n\t\tg.selectAll('.rect').select('rect').transition()\n\t\t\t.duration( transitionDuration )\t\n\t\t\t.attr('x', function(d) { return x(xValue(d)) })\t\t\n\t\t\t.attr('y', function(d) { return y(yValue(d)) })\n\t\t\t.attr('width', function(d) { return x(xValue(d)+wValue(d)) - x(xValue(d));})\t\t\t\t\t\t\t\t\t\n\t\t\t.attr('height', function(d) { return innerHeight - y(yValue(d)); });\n\t    \n\n\t\t// Add title on hover\t   \n\t    if (tooltip) {\t \n\t    \tvar tt = d3.select('.iobio-tooltip')   \t\n\t    \tutils.tooltipHelper(g.selectAll('.rect'), tt, tooltip);\n\t    }\n\n\t    // Attach events\n\t\tevents.forEach(function(ev) {\n\t\t\tvar cb = ev.listener ? function() {ev.listener.call(chart, svg)} : null;\n\t\t\tg.selectAll('.rect').on(ev.event, cb);\t\t\t\n\t\t})\t\n\n\t}\n\t// Rebind methods in base.js to this chart\n\tbase.rebind(chart);\n\n\t/*\n   \t * Set events on rects\n   \t */\n\tchart.on = function(event, listener) {\n\t\tif (!arguments.length) return events;\n\t\tevents.push( {'event':event, 'listener':listener})\n\t\treturn chart;\n\t}\n\n\t/*\n   \t * Set tooltip that appears when mouseover rects\n   \t */\n\tchart.tooltip = function(_) {\n\t\tif (!arguments.length) return tooltip;\n\t\t\ttooltip = _;\n\t\t\treturn chart; \n\t}\n\n\treturn chart;\n}\n\n// Export alignment\nmodule.exports = bar;","var barViewer = function() {\n\t// Import base chart\n\tvar bar = require('./bar.js'),\n\t\tutils = require('../utils.js'),\n\t\textend = require('extend');\n\n\t// Defaults\n\tvar events = [],\n\t\ttooltip,\n\t\tsizeRatio = 0.8,\n\t\torigHeight;\n\n\t// Default Options\n\tvar defaults = { };\n\n\t// Base Chart\n\tvar baseBar = bar();\n\n\tfunction chart(selection, opts) {\n\t\t// Merge defaults and options\n\t\tvar options = {};\n\t\textend(options, defaults, opts);\n\n\t\torigHeight = chart.height();\n\n\t\t// Setup both chart divs\n\t\tselection.selectAll('div')\n\t\t\t\t.data([0,0])\n\t\t\t.enter().append('div')\n\t\t\t\t.attr('class', function(d,i) { return 'iobio-bar-' + i + ' iobio-barViewer' });\n\n\t\t// Call big bar chart\n\t\tvar focalBar = bar()\n\t\t\t.height( origHeight * sizeRatio )\n\t\t\t.xValue( chart.xValue() )\n\t\t\t.yValue( chart.yValue() )\n\t\t\t.wValue( chart.wValue() )\n\t\t\t.xAxis( chart.xAxis() )\n\t\t\t.yAxis( chart.yAxis() )\n\t\t\t.margin( chart.margin() )\n\t\t\t.width( chart.width() )\n\t\t\t.y( chart.y() )\n\t\t\t.x( chart.x() )\n\t\t\t.id( chart.id() )\n\n\t\tvar focalSelection = selection.select('.iobio-bar-0').datum( selection.datum() )\n\t\tfocalBar(focalSelection, options);\n\n\t\t// Call little bar chart\n\t\tvar globalBar = bar()\n\t\t\t.xValue( chart.xValue() )\n\t\t\t.yValue( chart.yValue() )\n\t\t\t.wValue( chart.wValue() )\n\t\t\t.xAxis( chart.xAxis() )\n\t\t\t.yAxis( null )\n\t\t\t.margin( chart.margin() )\n\t\t\t.width( chart.width() )\n\t\t\t.id( chart.id() )\n\t\t\t.height( origHeight * (1-sizeRatio) )\n\t\t\t.brush('brush', function() {\n\t\t\t\tvar x2 = globalBar.x(), brush = globalBar.brush();\n\t        \tvar x = brush.empty() ? x2.domain() : brush.extent();\n\t        \tvar datum = globalSelection.datum().filter(function(d) {\n\t        \t\treturn (globalBar.xValue()(d) >= x[0] && globalBar.xValue()(d) <= x[1])\n\t        \t});\n\t        \toptions.xMin = x[0];\n\t        \toptions.xMax = x[1];\n\t        \toptions.globalBar = globalBar;\n\t           \tfocalBar( focalSelection.datum(datum), options );\n\t\t\t});\n\n\t\tvar globalSelection = selection.select('.iobio-bar-1').datum( selection.datum() )\n\t\tglobalBar(globalSelection, options);\n\n\t\t// // Add title on hover\n\t //    if (tooltip) {\n\t //    \tvar tt = d3.select('.iobio-tooltip')\n\t //    \tutils.tooltipHelper(g.selectAll('.rect'), tt, tooltip);\n\t //    }\n\n\t //    // Attach events\n\t\t// events.forEach(function(ev) {\n\t\t// \tvar cb = ev.listener ? function() {ev.listener.call(chart, svg)} : null;\n\t\t// \tg.selectAll('.rect').on(ev.event, cb);\n\t\t// })\n\t\t// focalBar.rebind(this);\n\t}\n\n\t// Rebind methods in bar chart to this chart\n\tbaseBar.rebind(chart);\n\n\t/*\n   \t * Set events on rects\n   \t */\n\tchart.sizeRatio = function(_) {\n\t\tif (!arguments.length) return sizeRatio;\n\t\tsizeRatio = _;\n\t\treturn chart;\n\t};\n\n\t/*\n   \t * Set events on rects\n   \t */\n\tchart.on = function(event, listener) {\n\t\tif (!arguments.length) return events;\n\t\tevents.push( {'event':event, 'listener':listener})\n\t\treturn chart;\n\t}\n\n\t/*\n   \t * Set tooltip that appears when mouseover rects\n   \t */\n\tchart.tooltip = function(_) {\n\t\tif (!arguments.length) return tooltip;\n\t\ttooltip = _;\n\t\treturn chart;\n\t}\n\n\treturn chart;\n}\n\n// Export alignment\nmodule.exports = barViewer;","var utils = require('../utils.js'),\n\textend = require('extend');\n\nvar base = function() {\n    // Initialize\n\n\t// Dimensions\n\tvar margin = {top: 0, right: 0, bottom: 0, left:0},\n\t    width = 800,\n\t  \theight = 500;\n\n\t// Scales\n\tvar x = d3.scale.linear().nice(),\n\t    y = d3.scale.linear().nice();\n\n\t// Axes\n\tvar xAxis = d3.svg.axis()\n\t\t\t.scale(x)\n\t\t\t.orient(\"bottom\")\n\t\t\t.tickFormat(utils.format_unit_names)\n\t\t\t.ticks(5),\n\t\tyAxis = d3.svg.axis()\n\t\t\t.scale(y)\n\t\t\t.orient(\"left\")\n\t\t\t.ticks(5);\n\n\t// Value transformers\n\tvar xValue = function(d) { return d[0]; },\n   \t \tyValue = function(d) { return d[1]; },\n       \twValue = function(d) { return d[2] || 1 },\n       \tid = function(d) { return null; };\n\n    // Color\n    var colorScale = d3.scale.category10(),\n    \tcolor = function(d,i) { return colorScale(i); };\n\n\t// Defaults\n\tvar events = [],\n\t\ttooltip,\n\t\tbrush = d3.svg.brush(),\n\t\tpreserveAspectRatio,\n\t\ttransitionDuration = 400;\n\n\t// Default options\n\tvar defaults = {};\n\n\tfunction chart(selection, opts) {\n\t\tvar options = {};\n\t\textend(options, defaults, opts);\n\n      \t// Get container\n      \tvar container = d3.select( selection.node() );\n      \tvar data = selection.datum();\n\n      \t// Select the svg element, if it exists.\n\t\tvar svg = container.selectAll(\"svg\").data([0]);\n\t\tchart.svg = svg;\n\n   \t\t// Otherwise, create svg.\n\t\tvar gEnter = svg.enter().append(\"svg\").append('g').attr('class', 'iobio-container');\n\t\tvar g = svg.select('g');\n\n\t\t// Update the outer dimensions.\n      \tsvg.attr(\"width\", width)\n        \t.attr(\"height\", height);\n\n      \t// Update the inner dimensions.\n\t\tg.attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n\t\t// Get width, height in pixels (necessary to allow percentages to work)\n\t\tvar boundingClientRect = svg.node().getBoundingClientRect();\n\t\tvar widthPx = boundingClientRect.width;\n\t\tvar heightPx = boundingClientRect.height;\n\t\tvar innerHeight = heightPx - margin.top - margin.bottom;\n\n\t\t// Make svg resize when window resizes\n\t\tsvg.attr('viewBox', '0 0 ' + widthPx + ' ' + heightPx);\n\t\tif (preserveAspectRatio) svg.attr('preserveAspectRatio', preserveAspectRatio);\n\t\tcontainer.style('-webkit-flex', '1 1 auto')\n\t\tcontainer.style('flex', '1 1 auto')\n\t\tcontainer.style('-webkit-order', '1')\n\t\tcontainer.style('order', '1')\n\n\t\t// Convert data to standard representation greedily;\n   \t\t// this is needed for nondeterministic accessors.\n   \t\tdata = data.map(function(d, i) {return [xValue.call(data, d, i), yValue.call(data, d, i), wValue.call(data, d, i)];});\n\n   \t\tvar xMin = (options.xMin === undefined || options.xMin === null) ? d3.min(data, function(d) { return d[0]}) : options.xMin;\n   \t\tvar xMax = (options.xMax === undefined || options.xMax === null) ? d3.max(data, function(d) { return d[0]+d[2]}) : options.xMax;\n\n\t\t// Update x scale\n\t\tx.domain([xMin, xMax]);\n\t\tx.range([0, widthPx - margin.left - margin.right]);\n\n\t\tvar yMin = (options.yMin === undefined || options.yMin === null) ? d3.min(data, function(d) { return d[1]}) : options.yMin;\n\t\tvar yMax = (options.yMax === undefined || options.yMax === null) ? d3.max(data, function(d) { return d[1]}) : options.yMax;\n\n\t\t// Update y scale\n\t\ty.domain( [yMin, yMax] )\n   \t \t .range([innerHeight , 0]);\n\n   \t \t// Flesh out skeletal chart\n   \t \tgEnter.append(\"g\").attr(\"class\", \"iobio-x iobio-axis\").attr(\"transform\", \"translate(0,\" + y.range()[0] + \")\");\n   \t \tgEnter.append(\"g\").attr(\"class\", \"iobio-y iobio-axis\");\n   \t\tgEnter.append(\"g\").attr(\"class\", \"iobio-x iobio-brush\");\n   \t\td3.select(\"body\").append(\"div\").attr(\"class\", \"iobio-tooltip\").style(\"opacity\", 0);\n\n\t\t// Update the x-axis.\n\t\tif(xAxis)\n\t\t\tg.select(\".iobio-x.iobio-axis\").transition()\n\t\t\t\t.duration(transitionDuration)\n\t\t\t\t.call(xAxis);\n\n\t\t// Update the y-axis.\n\t\tif(yAxis)\n\t\t\tg.select(\".iobio-y.iobio-axis\").transition()\n\t\t\t\t.duration(transitionDuration)\n\t\t\t\t.call(yAxis);\n\n\t\t// Add title on hover\n\t    if (tooltip) {\n\t    \tvar tt = d3.select('.iobio-tooltip')\n\n\t    \tsvg\n\t\t\t\t.on(\"mouseover\", function(d,i) {\n\t\t\t\t\tvar pos = {\n\t\t\t    \t\tx: parseInt(x.invert(d3.event.pageX - svg.node().getBoundingClientRect().left - margin.left )),\n\t\t\t    \t\ty: parseInt(y.invert(d3.event.pageY - svg.node().getBoundingClientRect().top - margin.top ))\n\t\t\t    \t}\n\t\t\t\t\tvar opacity = tooltip.call(chart, svg, pos) ? .9 : 0; // don't show if tooltipStr is null\n\t\t\t\t\ttt.transition()\n\t\t\t\t\t\t.duration(transitionDuration)\n\t\t\t\t\t\t.style(\"opacity\", opacity);\n\t\t\t\t\ttt.html(tooltip.call(chart, svg, pos))\n\t\t\t\t\t\t.style(\"left\", (d3.event.pageX) + \"px\")\n\t\t\t\t\t\t.style(\"text-align\", 'left')\n\t\t\t\t\t\t.style(\"top\", (d3.event.pageY - 24) + \"px\");\n\t\t\t\t})\n\t\t\t\t.on(\"mouseout\", function(d) {\n\t\t\t\t\ttt.transition()\n\t\t\t\t\t\t.duration(500)\n\t\t\t\t\t\t.style(\"opacity\", 0);\n\t\t\t\t})\n\t\t    \t.on(\"mousemove\", function() {\n\t\t    \t\tvar pos = {\n\t\t\t    \t\tx: parseInt(x.invert(d3.event.pageX - svg.node().getBoundingClientRect().left - margin.left )),\n\t\t\t    \t\ty: parseInt(y.invert(d3.event.pageY - svg.node().getBoundingClientRect().top - margin.top ))\n\t\t\t    \t}\n\t\t    \t\tvar opacity = tooltip.call(chart, svg, pos) ? .9 : 0; // don't show if tooltip is null\n\t\t    \t\ttt.style('opacity', opacity)\n\t\t            tt.html( tooltip.call(chart, svg, pos) )\n\t\t               .style(\"left\", (d3.event.pageX) + \"px\")\n\t\t               .style(\"top\", (d3.event.pageY - 24) + \"px\");\n\t          })\n\t    }\n\n\t    // Add brush\n\t    if( brush.on(\"brushend\") || brush.on(\"brushstart\") || brush.on(\"brush\") ) {\n\t    \tbrush.x(x);\n      \t\tsvg.select(\".iobio-brush\")\n\t\t\t\t\t.call(brush)\n\t\t\t\t.selectAll(\"rect\")\n\t\t\t\t\t.attr(\"y\", -6)\n\t\t\t\t\t.attr(\"height\", innerHeight + 6);\n\t    }\n\n\t\t// Attach events\n\t\tevents.forEach(function(ev) {\n\t\t\tvar cb = ev.listener ? function() {ev.listener.call(chart, svg)} : null;\n\t\t\tsvg.on(ev.event, cb);\n\t\t})\n\n\t\treturn data;\n\t}\n\n\t// Member functions\n\tchart.margin = function(_) {\n    \tif (!arguments.length) return margin;\n    \tmargin = _;\n    \treturn chart;\n  \t};\n\n\tchart.width = function(_) {\n\t\tif (!arguments.length) return width;\n\t\twidth = _;\n\t\treturn chart;\n\t};\n\n\tchart.height = function(_) {\n\t\tif (!arguments.length) return height;\n\t\theight = _;\n\t\treturn chart;\n\t};\n\n\tchart.x = function(_) {\n\t\tif (!arguments.length) return x;\n\t\tx = _;\n\t\treturn chart;\n\t};\n\n\tchart.y = function(_) {\n\t\tif (!arguments.length) return y;\n\t\ty = _;\n\t\treturn chart;\n\t};\n\n\tchart.xValue = function(_) {\n\t\tif (!arguments.length) return xValue;\n\t\txValue = _;\n\t\treturn chart;\n\t};\n\n\tchart.yValue = function(_) {\n\t\tif (!arguments.length) return yValue;\n\t\tyValue = _;\n\t\treturn chart;\n\t};\n\n\tchart.wValue = function(_) {\n\t\tif (!arguments.length) return wValue;\n\t\twValue = _;\n\t\treturn chart;\n\t};\n\n\tchart.id = function(_) {\n\t\tif (!arguments.length) return id;\n\t\tid = _;\n\t\treturn chart;\n\t};\n\n\tchart.xAxis = function(_) {\n\t\tif (!arguments.length) return xAxis;\n\t\txAxis = _;\n\t\treturn chart;\n\t};\n\n\tchart.yAxis = function(_) {\n\t\tif (!arguments.length) return yAxis;\n\t\tyAxis = _;\n\t\treturn chart;\n\t};\n\n\tchart.preserveAspectRatio = function(_) {\n\t\tif (!arguments.length) return preserveAspectRatio;\n\t\tpreserveAspectRatio = _;\n\t\treturn chart;\n\t};\n\n\tchart.getBoundingClientRect = function(_) {\n\t\treturn this.svg.node().getBoundingClientRect();\n\t};\n\n\tchart.transitionDuration = function(_) {\n\t\tif (!arguments.length) return transitionDuration;\n\t\ttransitionDuration = _;\n\t\treturn chart;\n\t};\n\n\tchart.color = function(_) {\n\t\tif (!arguments.length) return color;\n\t\tcolor = _;\n\t\treturn chart;\n\t};\n\n\t/*\n   \t * Add brush to chart\n   \t */\n\tchart.brush = function(event, listener) {\n\t\tif (!arguments.length) return brush;\n\t\tbrush.on(event, function() {\n\t\t\tlistener.call(this, brush);\n\t\t} );\n\t\treturn chart;\n\t}\n\n\t/*\n   \t * Add events to chart\n   \t */\n\tchart.onChart = function(event, listener) {\n\t\tif (!arguments.length) return events;\n\t\tevents.push({'event': event, 'listener': listener});\n\t\treturn chart;\n\t}\n\n\t/*\n   \t * Set tooltip that appears when mouseover chart\n   \t */\n\tchart.tooltipChart = function(_) {\n\t\tif (!arguments.length) return tooltip;\n\t\ttooltip = _;\n\t\treturn chart;\n\t}\n\n\t// utility functions\n\n\n\t/*\n   \t * Easy method to rebind base chart functions to the argument chart\n   \t */\n\tchart.rebind = function(object) {\n\t\tutils.rebind(object, this, 'rebind', 'margin', 'width', 'height', 'x', 'y', 'id',\n\t\t\t'xValue', 'yValue', 'wValue', 'xAxis', 'yAxis', 'brush', 'onChart',\n\t\t\t'tooltipChart', 'preserveAspectRatio', 'getBoundingClientRect', 'transitionDuration', 'color');\n\t}\n\n\treturn chart\n}\n\nmodule.exports = base;\n","//\n// consumes data in following format\n// var data = [ {name: 'somename',\n//              start: someInt,\n//              end : someInt,\n//              strand : '+',\n//              features : [{start:someInt, end:someInt, feature_type:utr, strand:'+'},\n//                          {start:someInt, end:someInt, feature_type:cds}, ...]\n//            }, ... ]\n//\n\nvar gene = function() {\n    // Import base chart\n    var base = require('./base.js')(),\n        utils = require('../utils.js'),\n        extend = require('extend');\n\n    // Defaults\n    var events = [],\n        tooltip,\n        trackHeight = 20,\n        borderRadius = 1,\n        utrHeight = undefined,\n        cdsHeight = undefined,\n        arrowHeight = undefined,    \n        start = function(d) { return d.start; },\n        end = function(d) { return d.end; },\n        title = function(d) { return d.transcript_id; };\n\n    // Default Options\n    var defaults = { };\n\n    // Modify Base Chart\n    base\n        .yAxis(null)\n        .xValue(function(d) { return start(d); })\n        .yValue(function(d,i) { return i; })\n        .wValue(function(d) { return end(d) - start(d); })          \n\n    function chart(selection, opts) {\n        // Merge defaults and options\n        var options = {};\n        extend(options, defaults, opts);\n\n        // Set variables if not user set\n        utrHeight = utrHeight || trackHeight / 2;\n        arrowHeight = arrowHeight || trackHeight / 2;\n        cdsHeight = cdsHeight || trackHeight;\n\n        // Call base chart\n        base.call(this, selection, options)                    \n\n        // Grab base functions for easy access\n        var x = base.x(),\n            y = base.y(),\n            id = base.id();\n            xValue = base.xValue(),\n            yValue = base.yValue(),     \n            wValue = base.wValue(),\n            color = base.color(),\n            transitionDuration = base.transitionDuration();            \n\n        // Grab Container\n        var g = selection.select('g.iobio-container').classed('iobio-gene', true); // grab container to draw into (created by base chart) \n\n        // Move Axis up\n        g.select('.iobio-axis').attr('transform', 'translate(0,-25)');    \n\n\n        // Draw\n        // enter        \n        var transcript = g.selectAll('.transcript')\n                .data(selection.datum())\n        // exit\n        transcript.exit().remove()           \n            \n        // enter\n        transcript.enter().append('g')\n                .attr('class', 'transcript')\n                .attr('id', id )\n                .attr('transform', function(d,i) { return \"translate(0,0)\"});\n\n        transcript.selectAll('.reference').data(function(d) { return [[start(d), end(d)]] })\n            .enter().append('line')\n                .attr('class', 'reference')\n                .attr('x1', function(d) { return x(d[0])})\n                .attr('x2', function(d) { return x(d[1])})                    \n                .attr('y1', trackHeight/2)\n                .attr('y2', trackHeight/2);\n        \n        transcript.selectAll('.name').data(function(d) { return [[start(d), title(d)]] })\n            .enter().append('text')\n                .attr('class', 'name')\n                .attr('x', function(d) { return x(d[0])-5; })\n                .attr('y', trackHeight/2)\n                .attr('text-anchor', 'end')\n                .attr('alignment-baseline', 'middle')\n                .text( function(d) { return d[1]; } )\n                .style('fill-opacity', 0)\n        \n        transcript.selectAll('.arrow').data(centerSpan)\n            .enter().append('path')\n                .attr('class', 'arrow')\n                .attr('d', centerArrow);      \n        \n        transcript.selectAll('.feature').data(function(d) { \n            return d['features'].filter( function(d) { var ft = d.feature_type.toLowerCase(); return ft == 'utr' || ft == 'cds';}) \n        }).enter().append('g')\n                .attr('class', function(d) { return d.feature_type.toLowerCase() + ' feature';})\n                .style('fill', color )\n                .append('rect')\n                    .attr('rx', borderRadius)\n                    .attr('ry', borderRadius)\n                    .attr('x', function(d) { return x(d.start)})\n                    .attr('width', function(d) { return x(d.end) - x(d.start)})\n                    .attr('y', trackHeight /2)\n                    .attr('height', 0); \n\n        // update \n        transcript.transition()\n                .duration(700)\n                .attr('transform', function(d,i) { return \"translate(0,\" + y(i) + \")\"});\n\n        transcript.selectAll('.reference').transition()\n            .duration(700)\n            .attr('x1', function(d) { return x(d[0])})\n            .attr('x2', function(d) { return x(d[1])});\n\n        transcript.selectAll('.arrow').transition()\n            .duration(700)\n            .attr('d', centerArrow);\n\n        transcript.selectAll('.name').transition()\n            .duration(700)\n            .attr('x', function(d) { return x(d[0])-5; })\n            .attr('y', trackHeight/2)   \n            .text( function(d) { return d[1]; } )\n            .style('fill-opacity', 1);\n\n        transcript.selectAll('.feature').select('rect').sort(function(a,b){ return parseInt(a.start) - parseInt(b.start)})\n            .transition()        \n                .duration(700)\n                .attr('x', function(d) { return x(d.start)})\n                .attr('width', function(d) { return x(d.end) - x(d.start)})\n                .attr('y', function(d) { \n                    if(d.feature_type.toLowerCase() =='utr') return (trackHeight - utrHeight)/2; \n                    else return (trackHeight - cdsHeight)/2; })\n                .attr('height', function(d) { \n                    if(d.feature_type.toLowerCase() =='utr') return utrHeight; \n                    else return cdsHeight; });         \n\n        // Add tooltip on hover      \n        if (tooltip) {   \n            var tt = d3.select('.iobio-tooltip')    \n            utils.tooltipHelper(transcript.selectAll('.utr,.cds'), tt, tooltip);\n        } \n\n    }\n    // Rebind methods in base.js to this chart\n    base.rebind(chart);\n\n    // Helper Functions\n\n    // moves selection to front of svg\n    function moveToFront(selection) {\n        return selection.each(function(){\n             this.parentNode.appendChild(this);\n        });\n    }\n\n    // updates the hash with the center of the biggest span between features\n    function centerSpan(d) {    \n        var span = 0;\n        var center = 0;\n        var sorted = d.features\n            .filter(function(f) { var ft = f.feature_type.toLowerCase(); return ft == 'utr' || ft == 'cds'})\n            .sort(function(a,b) { return parseInt(a.start) - parseInt(b.start)});\n\n        for (var i=0; i < sorted.length-1; i++) {\n            var currSpan = parseInt(sorted[i+1].start) - parseInt(sorted[i].end);\n            if (span < currSpan) {\n                span = currSpan;\n                center = parseInt(sorted[i].end) + span/2;\n            }\n        }      \n        d.center = center;\n        return [d]; \n    }\n\n    // generates the arrow path\n    function centerArrow(d) {\n        var x = chart.x();\n        var arrowHead = parseInt(d.strand + '5');\n        var pathStr = \"M \";            \n        pathStr += x(d.center) + ' ' + (trackHeight - arrowHeight)/2;\n        pathStr += ' L ' + parseInt(x(d.center)+arrowHead) + ' ' + trackHeight/2;\n        pathStr += ' L ' + x(d.center) + ' ' + parseInt(trackHeight + arrowHeight)/2;\n        return pathStr;\n    }\n  \n    chart.trackHeight = function(_) {\n        if (!arguments.length) return trackHeight;\n        trackHeight = _;\n        return chart;\n    };\n\n    chart.utrHeight = function(_) {\n        if (!arguments.length) return utrHeight;\n        utrHeight = _;\n        return chart;\n    };\n\n    chart.cdsHeight = function(_) {\n        if (!arguments.length) return cdsHeight;\n        cdsHeight = _;\n        return chart;\n    };\n\n    chart.arrowHeight = function(_) {\n        if (!arguments.length) return arrowHeight;\n        arrowHeight = _;\n        return chart;\n    };\n    \n\n    chart.start = function(_) {\n        if (!arguments.length) return start;\n        start = _;\n        return chart;\n    };\n\n    chart.end = function(_) {\n        if (!arguments.length) return end;\n        end = _;\n        return chart;\n    };\n\n    chart.title = function(_) {\n        if (!arguments.length) return title;\n        title = _;\n        return chart;\n    };\n\n    chart.tooltip = function(_) {\n        if (!arguments.length) return tooltip;\n        tooltip = _;\n        return chart;\n    };\n\n    return chart;\n}\n\n// Export alignment\nmodule.exports = gene;","var line = function(container) {\n    // Import base chart\n    var base = require('./base.js')(),\n        utils = require('../utils.js'),\n        extend = require('extend');\n\n    // Defaults\n    var numBins = 4,\n        events = [],\n        tooltip;\n\n    // Default Options\n    var defaults = { };\n\n    function chart(selection, opts) {\n        // Merge defaults and options\n        var options = {};\n        extend(options, defaults, opts);\n\n        // Call base chart\n        base.call(this, selection, options);\n\n        // Grab base functions for easy access\n        var x = base.x(),\n            y = base.y(),\n            id = base.id();\n            xValue = base.xValue(),\n            yValue = base.yValue(),\n            wValue = base.wValue(),\n            transitionDuration = base.transitionDuration()\n            color = base.color();\n\n        // Draw\n        var lineGen = d3.svg.line()\n            .interpolate(\"linear\")\n            .x(function(d,i) { return +x( xValue(d) ); })\n            .y(function(d) { return +y( yValue(d) ); })\n\n        var g = selection.select('g.iobio-container').classed('iobio-line', true); // grab container to draw into (created by base chart)\n\n        // draw line\n        var gEnter = g.selectAll('.line').data([0])\n            .enter().append(\"path\")\n                .attr('class', \"line\")\n                .attr(\"d\", lineGen(selection.datum()) )\n                .style(\"stroke\", color)\n                .style(\"stroke-width\", \"2\")\n                .style(\"fill\", \"none\");\n\n        var path = g.select('path.line');\n        var totalLength = path.node().getTotalLength();\n\n        // draw line from left first time\n        gEnter\n            .attr(\"stroke-dasharray\", totalLength + \" \" + totalLength)\n            .attr(\"stroke-dashoffset\", totalLength);\n\n        path\n           .transition()\n             .duration( transitionDuration )\n             .attr('d', lineGen(selection.datum()) )\n             .ease(\"linear\")\n             .attr(\"stroke-dashoffset\", 0);\n   }\n\n    // Rebind methods in base.js to this chart\n    base.rebind(chart);\n\n   return chart;\n}\n\n// Export circle\nmodule.exports = line;\n","var multiLine = function() {\n\t// Import base chart\n\tvar lineBase = require('./line.js')(),\n\t\tutils = require('../utils.js'),\n\t\textend = require('extend');\n\n\n\t// Value transformers\n\tvar nameValue = function(d) { return d[0]; },\n   \t \tdataValue = function(d) { return d[1]; };\n\n   \t// Axes\n\tvar xAxis = d3.svg.axis()\n\t\t\t.orient(\"bottom\")\n\t\t\t.tickFormat(utils.format_unit_names)\n\t\t\t.ticks(5);\n\n\t// Defaults\n\tvar events = [],\n\tselected = 'all';\n\n\t// Default Options\n\tvar defaults = { };\n\n\tfunction chart(selection, opts) {\n\t\t// Merge defaults and options\n\t\tvar options = {};\n\t\textend(options, defaults, opts);\n\n\t\t// Get selected button if one\n\t\tselected = options.selected || 'all';\n\n\t\t// Grab base line functions for easy access\n        var xValue = chart.xValue(),\n        \tm = chart.margin(),\n        \tw = chart.width(),\n        \th = chart.height(),\n        \tx = chart.x(),\n        \ttransitionDuration = chart.transitionDuration();\n\n\t\t// Smoothing function\n\t\tvar smooth = iobio.viz.layout.pointSmooth()\n\t    \t.size(w)\n\t    \t.pos(function(d) { return d.globalPos + xValue(d)})\n\t    \t.epsilonRate(0.1);\n\n\t    // Add global positions to data\n\t    var curr = 0,\n\t    \tpoints = [],\n\t    \tselectedGlobalpos;\n\n\t    selection.datum().forEach(function(d,i) {\n\t      d.globalPos = curr;\n\t      var pointData = dataValue(d);\n\t      curr += chart.xValue()(pointData[pointData.length-1]);\n\t      pointData.forEach(function(p) {\n\t        p.globalPos = d.globalPos;\n\t      })\n\n\t      if (selected == 'all') {\n\t      \tpoints = points.concat(pointData);\n\t      } else {\n\t      \tif(selected == nameValue(d)) {\n\t      \t\tpoints = points.concat(pointData);\n\t      \t\tselectedGlobalpos = d.globalPos;\n\t      \t}\n\t      }\n\t    })\n\n\t\t// Create line div to place the line chart in\n\t\tselection.selectAll('.iobio-multi-line.line-panel').data([0]).enter().append('div').attr('class', 'iobio-multi-line line-panel')\n\t\t// Call base line chart\n\t\tif (selected == 'all') { // for all\n\t        lineBase\n\t        \t.yAxis(null)\n\t        \t.xAxis(null)\n\t        \t.call(this, selection.select('.line-panel').datum(smooth(points)), options);\n\t        // Remove brush for all\n\t        selection.select('.iobio-brush').selectAll(\"*\").remove();\n\t        selection.select('.iobio-axis.iobio-x').selectAll(\"*\").remove();\n\t    } else {\n\t    \tchart.selectedGlobalpos = selectedGlobalpos\n\t    \tlineBase\n        \t.yAxis(null)\n        \t.xAxis( xAxis.scale(x).tickFormat(function(d) {\n        \t\treturn (d - chart.selectedGlobalpos);\n        \t}) )\n        \t.call(this, selection.select('.line-panel').datum(smooth(points)), options);\n\t    }\n\n\t\t// Create buttons\n\t\tselection.selectAll('.iobio-multi-line.button-panel').data([0])\n\t\t\t.enter().append('div')\n\t\t\t\t.attr('class', 'iobio-multi-line button-panel')\n\t\t\t\t.style('width', w - m.left - m.right)\n\t\t\t\t.append('svg')\n\t\t\t\t\t.style('width', '100%');\n\n\t   \tvar button = selection.select('.button-panel svg').selectAll('.button')\n\t    \t\t\t \t.data( selection.datum(), function(d) { return nameValue(d); });\n\n\t    // Exit\n\t    button.exit().remove();\n\n\t   \t// Enter\n\t    var buttonEnter = button.enter().append('g')\n\t    \t.attr('class', 'button')\n\t    \t.attr('transform', function(d) {return 'translate(' + x(d.globalPos) + ')'; })\n\n\t\tbuttonEnter.append('rect')\n\t\t\t.attr('width', function(d) {\n\t\t\t\t\tvar data = dataValue(d);\n\t\t    \t\tvar last = parseInt(xValue(data[data.length-1]))+parseInt(d.globalPos)\n\t\t    \t\tvar xpos = x( last ) - x(parseInt(d.globalPos));\n\t\t    \t\treturn  xpos + 'px'\n\t\t    })\n\t\t    .style('fill', chart.color() )\n\t\t    .style('height', '20px');\n\n\t    buttonEnter.append('text')\n\t    \t.attr('y', 10)\n    \t\t.attr('x', function(d) {\n    \t\t\tvar data = dataValue(d);\n\t    \t\tvar last = parseInt(xValue(data[data.length-1]))+parseInt(d.globalPos)\n\t    \t\tvar xpos = (x( last ) - x(parseInt(d.globalPos)))/2;\n\t    \t\treturn  xpos + 'px'\n\t    \t})\n\t    \t.attr('alignment-baseline', 'middle')\n\t    \t.attr('text-anchor', 'middle')\n\t    \t.text(function(d) { return nameValue(d); });\n\n\t    // Update\n\t    button.transition()\n\t    \t.duration(transitionDuration)\n\t    \t.attr('transform', function(d) {return 'translate(' + x(d.globalPos) + ')'; });\n\n\n\t    button.select('rect').transition()\n\t    \t.duration(transitionDuration)\n\t    \t.attr('width', function(d) {\n\t    \t\tvar data = dataValue(d);\n\t    \t\tvar last = parseInt(xValue(data[data.length-1]))+parseInt(d.globalPos)\n\t    \t\tvar xpos = x( last ) - x(parseInt(d.globalPos));\n\t    \t\treturn  xpos + 'px'\n\t    \t});\n\n\t   \tbutton.select('text').transition()\n\t   \t\t.duration(transitionDuration)\n\t   \t\t.attr('x', function(d) {\n\t   \t\t\tvar data = dataValue(d);\n\t    \t\tvar last = parseInt(xValue(data[data.length-1]))+parseInt(d.globalPos)\n\t    \t\tvar xpos = (x( last ) - x(parseInt(d.globalPos)))/2;\n\t    \t\treturn  xpos + 'px'\n\t    \t});\n\n\n\t    // Attach events\n\t    var userClickCB;\n\t\tevents.forEach(function(ev) {\n\t\t\tif(ev.event == 'click')\n\t\t\t\tuserClickCB = ev.listener;\n\t\t\telse\n\t\t\t\tbutton.on(ev.event, ev.listener);\n\t\t})\n\n\t\t// // Add control click event to all buttons\n\t    button\n\t\t\t.on('click', function(d) {\n\t    \t\tvar xMin = d.globalPos;\n\t    \t\tvar xMax = d.globalPos + xValue(d.data[d.data.length-1]) ;\n\t    \t\tchart(selection, {'xMin': xMin, 'xMax': xMax, 'selected':nameValue(d) });\n\n\t    \t\t// Handle user event\n\t    \t\tif (userClickCB) userClickCB.call(this,d);\n\t    \t})\n\t    if (selected != 'all') {\n\t    \tselection.select('.line-panel .iobio-container').append('text')\n\t    \t\t\t.attr('id', 'back-ctrl')\n\t    \t\t\t.attr('x', m.left + 5)\n\t    \t\t\t.attr('y', 0)\n\t    \t\t\t.text('< All')\n\t    \t\t\t.on('click', function() {\n\t    \t\t\t\tthis.remove();\n\t\t\t\t\t\tchart(selection);\n\t\t\t\t\t\tif (userClickCB) userClickCB.call(this);\n\t    \t\t\t})\n\t    }\n\n\t}\n\n\t// Rebind methods in line chart to this chart\n\tlineBase.rebind(chart);\n\n\n\t// Member functions\n\tchart.dataValue = function(_) {\n\t\tif (!arguments.length) return dataValue;\n\t\tdataValue = _;\n\t\treturn chart;\n\t};\n\n\tchart.nameValue = function(_) {\n\t\tif (!arguments.length) return nameValue;\n\t\tnameValue = _;\n\t\treturn chart;\n\t};\n\n\tchart.getSelected = function(_) {\n\t\treturn selected;\n\t};\n\n\n\t/*\n   \t * Set events on buttons\n   \t */\n\tchart.on = function(event, listener) {\n\t\tif (!arguments.length) return events;\n\t\tevents.push( {'event':event, 'listener':listener})\n\t\treturn chart;\n\t}\n\n\n\treturn chart;\n}\n\n// Export alignment\nmodule.exports = multiLine;","var pie = function() {\n\t// Import base chart\n\tvar base = require('./base.js')(),\n\t\tutils = require('../utils.js'),\n\t\textend = require('extend');\n\n\t// Initialize\n\tvar total = 0;\n\n\t// Defaults\n\tvar radius = 90,\n\t\tinnerRadius = 0,\n\t\tarc,\n\t\ttext = function(data, total) {\n\t\t\tvar count = data[0].data;\n\t\t\tvar percent = utils.format_percent(count/total);\n\t\t\treturn \"<div class='iobio-percent'>\" + percent + \"%</div><div class='iobio-count'>\" + count + \"</div>\";\n\t\t};\n\n\t// Default Options\n\tvar defaults = { };\n\n\tfunction chart(selection, opts) {\n\t\t// Merge defaults and options\n\t\tvar options = {};\n\t\textend(options, defaults, opts);\n\n\t\t// Update arc\n\t\tarc = d3.svg.arc()\n      \t\t.outerRadius(radius)\n      \t\t.innerRadius(innerRadius);\n\n\t\t// Call base chart\n\t\tbase\n\t\t\t.width(radius*2)\n\t\t\t.height(radius*2)\n\t\t\t.xAxis(null)\n\t\t\t.yAxis(null);\n\t\tbase.call(this, selection, options);\n\n\t\t// Grab base functions for easy access\n\t\tvar color = base.color(),\n\t\t\tid = base.id(),\n\t\t\ttransitionDuration = base.transitionDuration();\n\n\t\t// Get Total\n\t\ttotal = 0;\n\t\tselection.datum().forEach(function(d) {\n\t\t\ttotal += d.data;\n\t\t})\n\n\t\t// Get bounding dimenions\n\t\tvar boundingCR = base.getBoundingClientRect();\n\n\t\t// Draw\n\t\tvar g = selection.select('g.iobio-container')\n\t\t\t.classed('iobio-pie', true)\n\t\t\t.attr('transform', 'translate(' +boundingCR.width/2+','+boundingCR.height/2+')'); // grab container to draw into (created by base chart)\n\t\tvar gData = g.selectAll('.arc')\n\t\t\t\t.data(selection.datum())\n\n\t\t// enter\n\t\tgData.enter().append(\"g\")\n\t\t\t.attr('class', 'arc')\n\t\t\t.style('fill', color)\n\t\t\t.append('path')\n\t\t\t\t.attr(\"d\", function(d) {\n\t\t\t\t\t// return arc(d);\n\t\t\t\t\treturn arc({\"data\":0,\"value\":0,\"startAngle\":0,\"endAngle\":0, \"padAngle\":0})\n\t\t\t\t})\n\t\t\t\t.attr('id', id)\n\t\t\t\t.each(function(d) { this._current = {\"data\":0,\"value\":0,\"startAngle\":0,\"endAngle\":0, \"padAngle\":0}; }); // store the initial angles\n\n       // update\n       g.selectAll('.arc').select('path').transition()\n         .duration( transitionDuration )\n         .attrTween(\"d\", arcTween);\n\n       \t// exit\n\t\tgData.exit().remove();\n\n\t\t// Add middle text\n\t\tg.selectAll('.iobio-center-text').data([0]).enter().append('foreignObject')\n\t\t\t.attr('x', -innerRadius)\n\t\t\t.attr('y', -13)\n\t\t\t.attr('width', innerRadius*2)\n\t\t\t.attr(\"class\", \"iobio-center-text\")\n\t\t\t// .append(\"xhtml:div\")\n\n\n\t\tg.selectAll('.iobio-center-text').html( text(selection.datum(), total) );\n\t\t// g.selectAll('.iobio-center-text').text( text(selection.datum(), total) );\n\n\t\t// Add title on hover\n\t    // if (tooltip) {\n\t    // \tvar tt = d3.select('.iobio-tooltip')\n\t    // \tutils.tooltipHelper(g.selectAll('.rect'), tt, tooltip);\n\t    // }\n\n\t    // Attach events\n\t\t// events.forEach(function(ev) {\n\t\t// \tvar cb = ev.listener ? function() {ev.listener.call(chart, svg)} : null;\n\t\t// \tg.selectAll('.rect').on(ev.event, cb);\n\t\t// })\n\n\n\n\t}\n\t// Rebind methods in base.js to this chart\n\tbase.rebind(chart);\n\n\t// Store the displayed angles in _current.\n\t// Then, interpolate from _current to the new angles.\n\t// During the transition, _current is updated in-place by d3.interpolate.\n\tfunction arcTween(a) {\n\t  var i = d3.interpolate(this._current, a);\n\t  this._current = i(0);\n\t  return function(t) {\n\t    return arc(i(t));\n\t  };\n\t}\n\n\n   \tchart.radius = function(_) {\n\t\tif (!arguments.length) return radius;\n\t\tradius = _;\n\t\treturn chart;\n\t};\n\n\tchart.innerRadius = function(_) {\n\t\tif (!arguments.length) return innerRadius;\n\t\tinnerRadius = _;\n\t\treturn chart;\n\t};\n\n\n\tchart.text = function(_) {\n\t\tif (!arguments.length) return text;\n\t\ttext = _;\n\t\treturn text;\n\t}\n\n\t/*\n   \t * Set tooltip that appears when mouseover rects\n   \t */\n\tchart.tooltip = function(_) {\n\t\tif (!arguments.length) return tooltip;\n\t\t\ttooltip = _;\n\t\t\treturn chart;\n\t}\n\n\treturn chart;\n}\n\n// Export alignment\nmodule.exports = pie;","var referenceGraph = function() {\n\tvar graph = require('../layout/graph.js')();\n\tvar diagonal = d3.svg.diagonal()\n    \t.projection(function(d) { return [d.y, d.x]; });\n    var utils = require('../utils.js'),\n    \textend = require('extend');\n\n\t// Import base chart\n\tvar base = require('./base.js')();\n\n\t// Defaults\n\tvar elemHeight = 10,\n\t\torientation = 'down',\n\t\tlevelHeight = 50,\n\t\tevents = [],\n\t\ttooltip,\n\t\tvariant = iobio.viz.svg.variant();\n\n    // Default Options\n    var defaults = { };\n\n\t// Remove y axis\n\tbase.yAxis(null);\n\n\tfunction chart(selection, opts) {\n\t\t// Merge defaults and options\n\t\tvar options = {};\n\t\textend(options, defaults, opts);\n\n\t\t// Call base chart\n\t\tbase.call(this, selection, options);\n\n\t\t// Grab base functions for easy access\n\t\tvar x = base.x(),\n\t\t\ty = base.y().domain([-1,1]),\n\t\t\tid = base.id(),\n\t\t\txValue = base.xValue(),\n\t\t\tyValue = base.yValue(),\n\t\t\twValue = base.wValue();\n\n\t\t// Set variant accessors\n\t\tvariant\n\t\t\t.xValue(function(d) { return x(+xValue(d)); })\n\t\t\t.wValue(function(d) { return x(xValue(d)+wValue(d)) - x(+xValue(d)); })\n\t\t\t.yValue(function(d) { return yValue(d)>0 ? y(0)+elemHeight : y(0); })\n\t\t\t.hValue(function(d) { return levelHeight * yValue(d); });\n\n\t\t// Draw nodes\n\t\tvar g = selection.select('g.iobio-container').classed('iobio-referenceGraph', true);; // grab container to draw into (created by base chart)\n\t\tvar gEnter = g.selectAll('g.node')\n\t\t\t\t.data(selection.datum(), function(d) { return d.id ; })\n\t\t\t.enter().append('svg:g')\n\t\t\t\t.attr('class', 'node')\n\n\t\t// Draw line\n\t\tselection.selectAll('g.node')\n\t\t\t.filter(function(d){ return yValue(d) == 0 })\n\t\t\t.append(\"svg:rect\")\n\t\t\t\t.attr('id', function(d) { return id(d)})\n\t\t\t\t.attr('x', function(d) { return x(+xValue(d)); })\n\t\t\t\t.attr('y', function(d) { return y(+yValue(d)); })\n\t\t\t\t.attr('width', function(d) { return x(xValue(d)+wValue(d)) - x(+xValue(d));})\n\t\t\t\t.attr('height', function(d) { return elemHeight })\n\t\t\t\t.attr('class', function(d) {\n\t\t\t\t\tvar step = +yValue(d);\n\t\t\t\t\tif (step == 0) return 'reference';\n\t\t\t\t\telse  if (step > 0) return 'below-variant';\n\t\t\t\t\telse return 'above-variant';\n\t\t\t\t});\n\n\t\t// Draw Variants\n\t\tselection.selectAll('g.node')\n\t\t\t.filter(function(d){ return yValue(d) != 0 })\n\t\t\t.append(\"svg:path\")\n\t\t\t\t.attr('id', function(d) { return id(d)})\n\t\t\t\t.attr('d', variant)\n\t\t\t\t.attr('class', function(d) {\n\t\t\t\t\tvar step = +yValue(d);\n\t\t\t\t\tif (step == 0) return 'reference';\n\t\t\t\t\telse  if (step > 0) return 'below-variant';\n\t\t\t\t\telse return 'above-variant';\n\t\t\t\t});\n\n\t\t// Add title on hover\n\t    if (tooltip) {\n\t    \tvar tt = d3.select('.iobio-tooltip')\n\t    \tutils.tooltipHelper(g.selectAll('.node'), tt, tooltip);\n\t    }\n\n\t    // Add events\n\t\tif (events.length > 0) {\n\t\t\tvar rect = g.selectAll('.node');\n\t\t\tevents.forEach(function(event) {\n\t\t\t\trect.on(event.type, event.action)\n\t\t\t})\n\t\t}\n\t}\n\t// Rebind methods in 2d.js to this chart\n\tbase.rebind(chart);\n\n\t/*\n   \t * Set events on variants\n   \t */\n\tchart.on = function(type, action) {\n\t\tevents.push( {'type':type, 'action':action})\n\t\treturn chart;\n\t}\n\n\t/*\n   \t * Set height of variant levels\n   \t */\n\tchart.levelHeight = function(_) {\n\t\tif (!arguments.length) return levelHeight;\n\t\tlevelHeight = _;\n\t\treturn chart;\n\t}\n\n\t/*\n   \t * Set drawing function for variants. Function must have the following\n   \t * accessor functions:\n   \t * xValue, yValue, wValue, hValue\n   \t */\n\tchart.variant = function(_) {\n\t\tif (!arguments.length) return variant;\n\t\tvariant = _;\n\t\treturn chart;\n\t}\n\n\t/*\n   \t * Set tooltip that appears when mouseover variants\n   \t */\n\tchart.tooltip = function(_) {\n\t\tif (!arguments.length) return tooltip;\n\t\t\ttooltip = _;\n\t\t\treturn chart;\n\t}\n\n\treturn chart;\n}\n\n// Export referenceGraph\nmodule.exports = referenceGraph;","\nvar viz = {};\n// add visualizations\nviz.base = require('./base.js')\nviz.pie = require('./pie.js')\nviz.alignment = require('./alignment.js')\nviz.referenceGraph = require('./referenceGraph.js')\nviz.line = require('./line.js')\nviz.bar = require('./bar.js')\nviz.barViewer = require('./barViewer.js')\nviz.gene = require('./gene.js')\nviz.multiLine = require('./multiLine.js')\n\nmodule.exports = viz;"]}